<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <title>
   Outbound Form â€“ Dynamic Allowed Fields
  </title>
  <link !important;="" ";="" #007bff;="" #0e1b32;="" #16213d;="" #19274b;="" #1a2b4f;="" #1c2e5e;="" #2f3b58;="" #334;="" #445;="" #6ea8fe;="" #aaa;="" #cbd7f3;="" #f66;="" #fff;="" #topbar="" +="" .4s;="" .divider="" .form-row="" .hidden="" .json-editor="" .json-error="" .noise-block,="" .peer-block="" .section="" .slider="" .slider:before="" .tab-content="" .tabs="" 0.3rem="" 0;="" 100%;="" 10px;="" 12px;="" 140px;="" 16px;="" 1px="" 1rem;="" 20px;="" 220px;="" 2px="" 3px;="" 400px;="" 4px;="" 50%;="" 6px;="" 8px="" 8px;="" <="" <script="" ],="" align-items:="" background-color:="" background:="" bold;="" border-bottom:="" border-radius:="" border:="" bottom:="" button="" button.active="" button:hover="" center;="" color:="" display:="" flex;="" font-weight:="" height:="" href="https:
  &lt;script src=" https:="" inline-block;="" input:checked="" input[type="number" justify-content:="" label="" left:="" margin-bottom:="" margin-top:="" margin:="" min-height:="" none="" none;="" padding:="" position:="" rel="stylesheet" relative;="" select,="" solid="" space-between;="" src="https:

  &lt;style&gt;
    
    body {
      margin: 0; 
      padding: 0;
      background-color: #0e1b32;
      font-family: Arial, sans-serif;
      color: #cbd7f3;
    }
    .container {
      width: 95%;
      max-width: 600px;
      margin: 20px auto;
      padding: 16px;
      background: #16213d;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      border-radius: 5px;
    }
    h2, h4 {
      margin-top: 0;
      color: #fff;
    }
    button {
      cursor: pointer;
    }
    .btn {
      padding: 6px 12px;
      border: none;
      background: #007bff;
      color: #fff;
      border-radius: 4px;
      font-size: 14px;
      margin: 2px;
    }
    .btn:hover {
      background: #0069d9;
    }
    .btn-green {
      background-color: #28a745;
    }
    .btn-green:hover {
      background-color: #218838;
    }
    .btn-secondary {
      background: #6c757d;
    }
    .btn-secondary:hover {
      background: #5a6268;
    }
    .btn-sm {
      font-size: 90%;
      padding: 4px 8px;
    }
    .btn-danger {
      background: #dc3545;
    }
    .btn-danger:hover {
      background: #c82333;
    }
    
    .btn-orange {
      background-color: orange;
      color: #fff;
    }
    .btn-orange:hover {
      background-color: darkorange;
    }
    
    .toggle-switch {
      position: relative;
      width: 45px;
      height: 22px;
      display: inline-block;
      margin-left: 8px;
      vertical-align: middle;
    }
    .toggle-switch input {
      display: none;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: " style="" stylesheet"="" textarea="" transform:="" transition:="" translatex(22px);="" white;="" width:="" {="" }=""/>
 </head>
 <body>
  <div class="container">
   <form action="{{ form_action_url or '#' }}" id="saveForm" method="POST" style="display: none;">
    <input id="jsonEditorHidden" name="jsonEditor" type="hidden"/>
   </form>
   <div id="topBar">
    <button class="btn btn-secondary" onclick="goBack()">
     Back
    </button>
    <h2>
     Manage Outbound
    </h2>
    <div>
     <button class="btn btn-green btn-sm" onclick="saveOutbound()">
      Save
     </button>
     <button class="btn btn-orange btn-sm" onclick="addWarpOutbound()">
      Warp Add
     </button>
    </div>
   </div>
   <div class="tabs">
    <button class="active" id="formTabBtn" onclick="switchTab('form')">
     Form Editor
    </button>
    <button id="jsonTabBtn" onclick="switchTab('json')">
     JSON Editor
    </button>
   </div>
   <div class="tab-content" id="tabContent">
    <div id="formTab">
     <div style="margin-bottom:16px;">
      <label>
       Link Import:
      </label>
      <input btn="" btn-sm"="" id="linkInput" onclick="convertLink()" placeholder="vmess:
        &lt;button class=" type="text"/>
      Import
      <span id="linkErrorMsg" style="color:#f66;">
      </span>
     </div>
     <div class="section">
      <h4>
       Basic Outbound Settings
      </h4>
      <div class="form-row">
       <label>
        Protocol:
       </label>
       <select id="protocolSelect">
       </select>
      </div>
      <div class="form-row">
       <label>
        Tag:
       </label>
       <input id="tagInput" type="text"/>
       <span id="tagWarning" style="color:#f66; display:none;">
        Duplicate or empty tag!
       </span>
      </div>
      <div class="form-row">
       <label>
        Send Through:
       </label>
       <input id="sendThroughInput" type="text"/>
      </div>
     </div>
     <div class="section hidden" id="freedomSection">
      <h4>
       Freedom Settings
      </h4>
      <div class="form-row">
       <label>
        Domain Strategy:
       </label>
       <select id="freedomDomainStrategy">
       </select>
      </div>
      <div class="form-row">
       <label>
        Redirect:
       </label>
       <input id="freedomRedirect" type="text"/>
      </div>
      <div class="form-row">
       <label>
        Fragment:
       </label>
       <label class="toggle-switch">
        <input id="freedomFragmentEnable" type="checkbox"/>
        <span class="slider">
        </span>
       </label>
      </div>
      <div class="hidden" id="freedomFragmentFields">
       <div class="form-row">
        <label>
         Packets:
        </label>
        <select id="freedomFragmentPackets">
         <option value="1-3">
          1-3
         </option>
         <option value="tlshello">
          tlshello
         </option>
        </select>
       </div>
       <div class="form-row">
        <label>
         Length:
        </label>
        <input id="freedomFragmentLength" type="text"/>
       </div>
       <div class="form-row">
        <label>
         Interval:
        </label>
        <input id="freedomFragmentInterval" type="text"/>
       </div>
      </div>
      <div class="form-row">
       <label>
        Noises:
       </label>
       <label class="toggle-switch">
        <input id="freedomNoisesEnable" type="checkbox"/>
        <span class="slider">
        </span>
       </label>
      </div>
      <div class="hidden" id="freedomNoisesContainer">
       <button class="btn btn-sm" onclick="addFreedomNoise()">
        Add Noise
       </button>
       <div id="freedomNoisesList">
       </div>
      </div>
     </div>
     <div class="section hidden" id="blackholeSection">
      <h4>
       Blackhole Settings
      </h4>
      <div class="form-row">
       <label>
        Response Type:
       </label>
       <select id="blackholeType">
        <option value="">
         (none)
        </option>
        <option value="none">
         none
        </option>
        <option value="http">
         http
        </option>
       </select>
      </div>
     </div>
     <div class="section hidden" id="dnsSection">
      <h4>
       DNS Settings
      </h4>
      <div class="form-row">
       <label>
        Network:
       </label>
       <select id="dnsNetwork">
        <option value="udp">
         udp
        </option>
        <option value="tcp">
         tcp
        </option>
       </select>
      </div>
      <div class="form-row">
       <label>
        non-IP Query:
       </label>
       <select id="dnsNonIPQuery">
        <option value="drop">
         drop
        </option>
        <option value="skip">
         skip
        </option>
       </select>
      </div>
      <div class="form-row hidden" id="dnsBlockTypesRow">
       <label>
        Block Types:
       </label>
       <input id="dnsBlockTypes" type="number"/>
      </div>
     </div>
     <div class="section hidden" id="wireguardSection">
      <h4>
       Wireguard Settings
      </h4>
      <div class="form-row">
       <label>
        Address:
       </label>
       <input id="wgAddress" type="text"/>
      </div>
      <div class="form-row">
       <label>
        Secret Key:
       </label>
       <button class="btn btn-sm" onclick="regenWireguardKeypair()">
        Regen
       </button>
       <input id="wgSecretKey" type="text"/>
      </div>
      <div class="form-row">
       <label>
        Public Key:
       </label>
       <input disabled="" id="wgPubKey" type="text"/>
      </div>
      <div class="form-row">
       <label>
        DomainStrategy:
       </label>
       <select id="wgDomainStrategy">
       </select>
      </div>
      <div class="form-row">
       <label>
        MTU:
       </label>
       <input id="wgMTU" type="number" value="1420"/>
      </div>
      <div class="form-row">
       <label>
        Workers:
       </label>
       <input id="wgWorkers" type="number" value="2"/>
      </div>
      <div class="form-row">
       <label>
        No Kernel Tun:
       </label>
       <label class="toggle-switch">
        <input id="wgNoKernelTun" type="checkbox"/>
        <span class="slider">
        </span>
       </label>
      </div>
      <div class="form-row">
       <label>
        Reserved:
       </label>
       <input id="wgReserved" type="text"/>
      </div>
      <div class="form-row">
       <label>
        Peers:
       </label>
       <button class="btn btn-sm" onclick="addWireguardPeer()">
        Add Peer
       </button>
      </div>
      <div id="wgPeersContainer">
      </div>
     </div>
     <div class="section hidden" id="addressPortSection">
      <h4>
       Address / Port
      </h4>
      <div class="form-row">
       <label>
        Address:
       </label>
       <input id="apAddress" type="text"/>
      </div>
      <div class="form-row">
       <label>
        Port:
       </label>
       <input id="apPort" type="number"/>
      </div>
     </div>
     <div class="section hidden" id="vnextSection">
      <h4>
       Vnext (VMess / VLESS)
      </h4>
      <div class="form-row">
       <label>
        ID:
       </label>
       <input id="vnextID" type="text"/>
      </div>
      <div class="form-row hidden" id="vmessSecurityRow">
       <label>
        Security:
       </label>
       <select id="vmessSecurity">
       </select>
      </div>
      <div class="form-row hidden" id="vlessFlowRow">
       <label>
        Flow:
       </label>
       <select id="vlessFlow">
        <option value="">
         (none)
        </option>
       </select>
      </div>
     </div>
     <div class="section hidden" id="serversSection">
      <h4>
       Servers
      </h4>
      <div class="form-row hidden" id="srvUserRow">
       <label>
        Username:
       </label>
       <input id="srvUser" type="text"/>
      </div>
      <div class="form-row hidden" id="srvPassRow">
       <label>
        Password:
       </label>
       <input id="srvPass" type="text"/>
      </div>
      <div class="form-row hidden" id="srvSSPassRow">
       <label>
        Password:
       </label>
       <input id="srvSSPassword" type="text"/>
      </div>
      <div class="form-row hidden" id="ssMethodRow">
       <label>
        Encryption:
       </label>
       <select id="ssMethod">
       </select>
      </div>
      <div class="form-row hidden" id="ssUotRow">
       <label>
        UDP over TCP:
       </label>
       <label class="toggle-switch">
        <input id="ssUot" type="checkbox"/>
        <span class="slider">
        </span>
       </label>
      </div>
      <div class="form-row hidden" id="ssUotVersionRow">
       <label>
        UoTVersion:
       </label>
       <input id="ssUotVersion" max="2" min="1" type="number" value="1"/>
      </div>
     </div>
     <div class="section hidden" id="streamSection">
      <h4>
       Stream Settings
      </h4>
      <div class="form-row">
       <label>
        Transmission:
       </label>
       <select id="streamNetwork">
       </select>
      </div>
      <div class="hidden" id="tcpSection">
       <div class="form-row">
        <label>
         HTTP Camouflage:
        </label>
        <label class="toggle-switch">
         <input id="tcpHTTPEnable" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
       <div class="hidden" id="tcpHTTPFields">
        <div class="form-row">
         <label>
          Host:
         </label>
         <input id="tcpHTTPHost" type="text"/>
        </div>
        <div class="form-row">
         <label>
          Path:
         </label>
         <input id="tcpHTTPPath" type="text"/>
        </div>
       </div>
      </div>
      <div class="hidden" id="kcpSection">
       <div class="form-row">
        <label>
         Camouflage:
        </label>
        <select id="kcpType">
        </select>
       </div>
       <div class="form-row">
        <label>
         Password(Seed):
        </label>
        <input id="kcpSeed" type="text"/>
       </div>
       <div class="form-row">
        <label>
         MTU:
        </label>
        <input id="kcpMTU" min="0" type="number" value="1350"/>
       </div>
       <div class="form-row">
        <label>
         TTI(ms):
        </label>
        <input id="kcpTTI" min="0" type="number" value="50"/>
       </div>
       <div class="form-row">
        <label>
         Uplink(MB/s):
        </label>
        <input id="kcpUpCap" min="0" type="number" value="5"/>
       </div>
       <div class="form-row">
        <label>
         Downlink(MB/s):
        </label>
        <input id="kcpDownCap" min="0" type="number" value="20"/>
       </div>
       <div class="form-row">
        <label>
         Congestion:
        </label>
        <label class="toggle-switch">
         <input id="kcpCongestion" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
       <div class="form-row">
        <label>
         ReadBuffer(MB):
        </label>
        <input id="kcpReadBuffer" min="0" type="number" value="2"/>
       </div>
       <div class="form-row">
        <label>
         WriteBuffer(MB):
        </label>
        <input id="kcpWriteBuffer" min="0" type="number" value="2"/>
       </div>
      </div>
      <div class="hidden" id="wsSection">
       <div class="form-row">
        <label>
         Host:
        </label>
        <input id="wsHost" type="text"/>
       </div>
       <div class="form-row">
        <label>
         Path:
        </label>
        <input id="wsPath" type="text" value="/"/>
       </div>
       <div class="form-row">
        <label>
         Heartbeat(s):
        </label>
        <input id="wsHeartbeat" min="0" type="number" value="0"/>
       </div>
      </div>
      <div class="hidden" id="grpcSection">
       <div class="form-row">
        <label>
         ServiceName:
        </label>
        <input id="grpcServiceName" type="text"/>
       </div>
       <div class="form-row">
        <label>
         Authority:
        </label>
        <input id="grpcAuthority" type="text"/>
       </div>
       <div class="form-row">
        <label>
         MultiMode:
        </label>
        <label class="toggle-switch">
         <input id="grpcMultiMode" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
      </div>
      <div class="hidden" id="httpupgradeSection">
       <div class="form-row">
        <label>
         Host:
        </label>
        <input id="httpupgradeHost" type="text"/>
       </div>
       <div class="form-row">
        <label>
         Path:
        </label>
        <input id="httpupgradePath" type="text" value="/"/>
       </div>
      </div>
      <div class="hidden" id="xhttpSection">
       <div class="form-row">
        <label>
         Host:
        </label>
        <input id="xhttpHost" type="text"/>
       </div>
       <div class="form-row">
        <label>
         Path:
        </label>
        <input id="xhttpPath" type="text" value="/"/>
       </div>
       <div class="form-row">
        <label>
         Mode:
        </label>
        <select id="xhttpMode">
         <option value="auto">
          auto
         </option>
         <option value="packet-up">
          packet-up
         </option>
         <option value="stream-up">
          stream-up
         </option>
         <option value="stream-one">
          stream-one
         </option>
        </select>
       </div>
       <div class="form-row">
        <label>
         noGRPCHeader:
        </label>
        <label class="toggle-switch">
         <input id="xhttpNoGRPCHeader" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
       <div class="form-row">
        <label>
         Min Upload Interval:
        </label>
        <input id="xhttpScMinPostsIntervalMs" type="text" value="30"/>
       </div>
       <div class="form-row">
        <label>
         maxConcurrency:
        </label>
        <input id="xhttpMaxConcurrency" type="text" value="16-32"/>
       </div>
       <div class="form-row">
        <label>
         maxConnections:
        </label>
        <input id="xhttpMaxConnections" type="number" value="0"/>
       </div>
       <div class="form-row">
        <label>
         cMaxReuseTimes:
        </label>
        <input id="xhttpCMaxReuseTimes" type="text" value="0"/>
       </div>
       <div class="form-row">
        <label>
         hMaxRequestTimes:
        </label>
        <input id="xhttpHMaxRequestTimes" type="text" value="600-900"/>
       </div>
       <div class="form-row">
        <label>
         hMaxReusableSecs:
        </label>
        <input id="xhttpHMaxReusableSecs" type="text" value="1800-3000"/>
       </div>
       <div class="form-row">
        <label>
         hKeepAlivePeriod:
        </label>
        <input id="xhttpHKeepAlivePeriod" type="number" value="0"/>
       </div>
      </div>
     </div>
     <div class="section hidden" id="tlsSection">
      <h4>
       Security (TLS / Reality)
      </h4>
      <div class="form-row">
       <label>
        Security:
       </label>
       <select id="tlsSecurity">
       </select>
      </div>
      <div class="hidden" id="tlsFields">
       <div class="form-row">
        <label>
         SNI:
        </label>
        <input id="tlsServerName" type="text"/>
       </div>
       <div class="form-row">
        <label>
         uTLS Fingerprint:
        </label>
        <select id="tlsFingerprintSelect">
        </select>
       </div>
       <div class="form-row">
        <label>
         ALPN (comma):
        </label>
        <input id="tlsAlpnInput" placeholder="e.g. h2,http/1.1" type="text"/>
       </div>
       <div class="form-row">
        <label>
         AllowInsecure:
        </label>
        <label class="toggle-switch">
         <input id="tlsAllowInsecure" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
      </div>
      <div class="hidden" id="realityFields">
       <div class="form-row">
        <label>
         SNI:
        </label>
        <input id="realityServerName" type="text"/>
       </div>
       <div class="form-row">
        <label>
         uTLS:
        </label>
        <select id="realityFingerprintSelect">
        </select>
       </div>
       <div class="form-row">
        <label>
         Short ID:
        </label>
        <input id="realityShortId" type="text"/>
       </div>
       <div class="form-row">
        <label>
         SpiderX:
        </label>
        <input id="realitySpiderX" type="text"/>
       </div>
       <div class="form-row">
        <label>
         PublicKey:
        </label>
        <input id="realityPublicKey" type="text"/>
       </div>
      </div>
     </div>
     <div class="section hidden" id="sockoptSection">
      <h4>
       Sockopt
      </h4>
      <div class="form-row">
       <label>
        Enable Sockopt:
       </label>
       <label class="toggle-switch">
        <input id="sockoptEnable" type="checkbox"/>
        <span class="slider">
        </span>
       </label>
      </div>
      <div class="hidden" id="sockoptFields">
       <div class="form-row">
        <label>
         Dialer Proxy:
        </label>
        <input id="sockoptDialerProxy" type="text"/>
       </div>
       <div class="form-row">
        <label>
         TCP Fast Open:
        </label>
        <label class="toggle-switch">
         <input id="sockoptTcpFastOpen" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
       <div class="form-row">
        <label>
         Keep Alive Interval:
        </label>
        <input id="sockoptTcpKeepAliveInterval" type="number" value="0"/>
       </div>
       <div class="form-row">
        <label>
         Multipath TCP:
        </label>
        <label class="toggle-switch">
         <input id="sockoptTcpMptcp" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
       <div class="form-row">
        <label>
         Penetrate:
        </label>
        <label class="toggle-switch">
         <input id="sockoptPenetrate" type="checkbox"/>
         <span class="slider">
         </span>
        </label>
       </div>
      </div>
     </div>
     <div class="section hidden" id="muxSection">
      <h4>
       MUX Settings
      </h4>
      <div class="form-row">
       <label>
        Enable Mux:
       </label>
       <label class="toggle-switch">
        <input id="muxEnable" type="checkbox"/>
        <span class="slider">
        </span>
       </label>
      </div>
      <div class="hidden" id="muxFields">
       <div class="form-row">
        <label>
         Concurrency:
        </label>
        <input id="muxConcurrency" type="number" value="8"/>
       </div>
       <div class="form-row">
        <label>
         xudpConcurrency:
        </label>
        <input id="muxXudpConcurrency" type="number" value="16"/>
       </div>
       <div class="form-row">
        <label>
         xudpProxyUDP443:
        </label>
        <select id="muxXudpProxyUDP443">
         <option value="reject">
          reject
         </option>
         <option value="allow">
          allow
         </option>
         <option value="skip">
          skip
         </option>
        </select>
       </div>
      </div>
     </div>
    </div>
    <div class="hidden" id="jsonTab">
     <div class="json-error" id="jsonError">
     </div>
     <div class="json-editor" id="jsonEditor">
     </div>
    </div>
   </div>
  </div>
  <script>
   let _rawOutboundJsonStr = `{{ outbound_data_json|safe if outbound_data_json else '{}' }}`;
  let outboundData = {};
  let isFormUpdateInProgress = false;
  let isEditorUpdateInProgress = false;
  let currentTab = "form";
  let cmEditor = null;

  const Protocols = {
    Freedom: "freedom",
    Blackhole: "blackhole",
    DNS: "dns",
    VMess: "vmess",
    VLESS: "vless",
    Trojan: "trojan",
    Shadowsocks: "shadowsocks",
    Socks: "socks",
    HTTP: "http",
    Wireguard: "wireguard"
  };

  function isEmpty(str) {
    return (!str || str.trim().length < 1);
  }

  
  window.addEventListener("load", () => {
    initSelectOptions();
    try {
      let j = JSON.parse(_rawOutboundJsonStr);
      outboundData = parseInboundJson(j);
    } catch (e) {
      outboundData = getDefaultOutbound(Protocols.Freedom);
    }
    fillFormFromOutbound();

    cmEditor = CodeMirror(document.getElementById("jsonEditor"), {
      value: JSON.stringify(outboundToJson(outboundData), null, 2),
      mode: "application/json",
      lineNumbers: true,
      theme: "dracula"
    });
    cmEditor.on("change", (cm) => {
      if (isEditorUpdateInProgress) return;
      isFormUpdateInProgress = true;
      try {
        let val = cmEditor.getValue();
        let j = JSON.parse(val);
        outboundData = parseInboundJson(j);
        fillFormFromOutbound();
        document.getElementById("jsonError").textContent = "";
      } catch (e) {
        document.getElementById("jsonError").textContent = "JSON parse error: " + e.message;
      }
      isFormUpdateInProgress = false;
    });

    attachFormListeners();

    
    document.getElementById("protocolSelect").addEventListener("change", () => {
      readFormIntoOutbound();
      fillFormFromOutbound();
      syncFormToJson();
    });
    document.getElementById("tlsSecurity").addEventListener("change", () => {
      readFormIntoOutbound();
      fillFormFromOutbound();
      syncFormToJson();
    });
    document.getElementById("streamNetwork").addEventListener("change", () => {
      fillStreamUI();
      syncFormToJson();
    });
    document.getElementById("tcpHTTPEnable").addEventListener("change", function() {
      if (this.checked)
        document.getElementById("tcpHTTPFields").classList.remove("hidden");
      else
        document.getElementById("tcpHTTPFields").classList.add("hidden");
      syncFormToJson();
    });
    document.getElementById("freedomFragmentEnable").addEventListener("change", function() {
      if (this.checked)
        document.getElementById("freedomFragmentFields").classList.remove("hidden");
      else
        document.getElementById("freedomFragmentFields").classList.add("hidden");
      syncFormToJson();
    });
    document.getElementById("freedomNoisesEnable").addEventListener("change", function() {
      if (this.checked) {
        document.getElementById("freedomNoisesContainer").classList.remove("hidden");
        buildFreedomNoisesList();
      } else {
        document.getElementById("freedomNoisesContainer").classList.add("hidden");
        document.getElementById("freedomNoisesList").innerHTML = "";
      }
      syncFormToJson();
    });
    document.getElementById("sockoptEnable").addEventListener("change", function() {
      if (this.checked)
        document.getElementById("sockoptFields").classList.remove("hidden");
      else
        document.getElementById("sockoptFields").classList.add("hidden");
      syncFormToJson();
    });
    document.getElementById("muxEnable").addEventListener("change", function() {
      if (this.checked)
        document.getElementById("muxFields").classList.remove("hidden");
      else
        document.getElementById("muxFields").classList.add("hidden");
      syncFormToJson();
    });
  });

  
  function getDefaultOutbound(proto) {
    let out = {
      protocol: proto,
      tag: "",
      sendThrough: "",
      settings: {},
      streamSettings: {},
      mux: {}
    };
    switch (proto) {
      case Protocols.Freedom:
        out.settings = { domainStrategy: "", redirect: "", fragment: {}, noises: [] };
        break;
      case Protocols.Blackhole:
        out.settings = { type: "" };
        break;
      case Protocols.DNS:
        out.settings = { network: "udp", address: "", port: 53, nonIPQuery: "drop", blockTypes: [] };
        break;
      case Protocols.VMess:
        out.settings = { address: "", port: 443, id: "", security: "auto" };
        out.streamSettings = { network: "tcp", security: "none", tcpSettings: { header: { type: "none" } } };
        break;
      case Protocols.VLESS:
        out.settings = { address: "", port: 443, id: "", flow: "" };
        out.streamSettings = { network: "tcp", security: "none", tcpSettings: { header: { type: "none" } } };
        break;
      case Protocols.Trojan:
        out.settings = { address: "", port: 443, password: "" };
        out.streamSettings = { network: "tcp", security: "none", tcpSettings: { header: { type: "none" } } };
        break;
      case Protocols.Shadowsocks:
        out.settings = { address: "", port: 443, password: "", method: "aes-256-gcm", uot: false, UoTVersion: 1 };
        out.streamSettings = { network: "tcp", security: "none", tcpSettings: { header: { type: "none" } } };
        break;
      case Protocols.Socks:
        out.settings = { address: "", port: 1080, user: "", pass: "" };
        break;
      case Protocols.HTTP:
        out.settings = { address: "", port: 80, user: "", pass: "" };
        break;
      case Protocols.Wireguard:
        out.settings = {
          mtu: 1420,
          secretKey: "",
          address: "",
          workers: 2,
          domainStrategy: "",
          reserved: "",
          peers: [{
            publicKey: "",
            psk: "",
            allowedIPs: ["0.0.0.0/0", "::/0"],
            endpoint: "",
            keepAlive: 0
          }],
          noKernelTun: false
        };
        
        break;
    }
    if ([Protocols.VMess, Protocols.VLESS, Protocols.Trojan, Protocols.Shadowsocks, Protocols.HTTP, Protocols.Socks].includes(proto)) {
      out.mux = { enabled: false, concurrency: 8, xudpConcurrency: 16, xudpProxyUDP443: "reject" };
    }
    return out;
  }

  function parseInboundJson(j) {
    let proto = j.protocol || Protocols.Freedom;
    let base = getDefaultOutbound(proto);
    if (!isEmpty(j.tag)) base.tag = j.tag;
    if (!isEmpty(j.sendThrough)) base.sendThrough = j.sendThrough;
    if (j.settings) {
      parseSettings(base, j.settings);
    }
    if (canEnableStream(proto) && j.streamSettings) {
      parseStreamSettings(base, j.streamSettings);
    }
    if (canEnableMux(proto) && j.mux) {
      parseMux(base.mux, j.mux);
    }
    return base;
  }
  function parseSettings(base, s) {
    switch (base.protocol) {
      case Protocols.Freedom:
        if (!isEmpty(s.domainStrategy)) base.settings.domainStrategy = s.domainStrategy;
        if (!isEmpty(s.redirect)) base.settings.redirect = s.redirect;
        if (s.fragment && typeof s.fragment === "object") {
          base.settings.fragment = {
            packets: s.fragment.packets || "1-3",
            length: s.fragment.length || "",
            interval: s.fragment.interval || ""
          };
        }
        if (Array.isArray(s.noises) && s.noises.length > 0) {
          base.settings.noises = s.noises.map(n => ({
            type: n.type || "rand",
            packet: n.packet || "10-20",
            delay: n.delay || "10-16"
          }));
        }
        break;
      case Protocols.Blackhole:
        if (s.response && !isEmpty(s.response.type)) base.settings.type = s.response.type;
        break;
      case Protocols.DNS:
        if (!isEmpty(s.network)) base.settings.network = s.network;
        if (!isEmpty(s.address)) base.settings.address = s.address;
        if (typeof s.port === "number") base.settings.port = s.port;
        if (!isEmpty(s.nonIPQuery)) base.settings.nonIPQuery = s.nonIPQuery;
        if (Array.isArray(s.blockTypes)) base.settings.blockTypes = s.blockTypes;
        break;
      case Protocols.VMess:
        if (Array.isArray(s.vnext) && s.vnext.length > 0) {
          let v0 = s.vnext[0];
          if (!isEmpty(v0.address)) base.settings.address = v0.address;
          if (typeof v0.port === "number") base.settings.port = v0.port;
          if (Array.isArray(v0.users) && v0.users.length > 0) {
            let u0 = v0.users[0];
            if (!isEmpty(u0.id)) base.settings.id = u0.id;
            if (!isEmpty(u0.security)) base.settings.security = u0.security;
          }
        }
        break;
      case Protocols.VLESS:
        if (Array.isArray(s.vnext) && s.vnext.length > 0) {
          let v0 = s.vnext[0];
          if (!isEmpty(v0.address)) base.settings.address = v0.address;
          if (typeof v0.port === "number") base.settings.port = v0.port;
          if (Array.isArray(v0.users) && v0.users.length > 0) {
            let u0 = v0.users[0];
            if (!isEmpty(u0.id)) base.settings.id = u0.id;
            if (!isEmpty(u0.flow)) base.settings.flow = u0.flow;
          }
        }
        break;
      case Protocols.Trojan:
        if (Array.isArray(s.servers) && s.servers.length > 0) {
          let sv0 = s.servers[0];
          if (!isEmpty(sv0.address)) base.settings.address = sv0.address;
          if (typeof sv0.port === "number") base.settings.port = sv0.port;
          if (!isEmpty(sv0.password)) base.settings.password = sv0.password;
        }
        break;
      case Protocols.Shadowsocks:
        if (Array.isArray(s.servers) && s.servers.length > 0) {
          let ss0 = s.servers[0];
          if (!isEmpty(ss0.address)) base.settings.address = ss0.address;
          if (typeof ss0.port === "number") base.settings.port = ss0.port;
          if (!isEmpty(ss0.password)) base.settings.password = ss0.password;
          if (!isEmpty(ss0.method)) base.settings.method = ss0.method;
          if (typeof ss0.uot === "boolean") base.settings.uot = ss0.uot;
          if (typeof ss0.UoTVersion === "number") base.settings.UoTVersion = ss0.UoTVersion;
        }
        break;
      case Protocols.Socks:
        if (Array.isArray(s.servers) && s.servers.length > 0) {
          let so = s.servers[0];
          if (!isEmpty(so.address)) base.settings.address = so.address;
          if (typeof so.port === "number") base.settings.port = so.port;
          if (Array.isArray(so.users) && so.users.length > 0) {
            let u = so.users[0];
            if (!isEmpty(u.user)) base.settings.user = u.user;
            if (!isEmpty(u.pass)) base.settings.pass = u.pass;
          }
        }
        break;
      case Protocols.HTTP:
        if (Array.isArray(s.servers) && s.servers.length > 0) {
          let ho = s.servers[0];
          if (!isEmpty(ho.address)) base.settings.address = ho.address;
          if (typeof ho.port === "number") base.settings.port = ho.port;
          if (Array.isArray(ho.users) && ho.users.length > 0) {
            let u = ho.users[0];
            if (!isEmpty(u.user)) base.settings.user = u.user;
            if (!isEmpty(u.pass)) base.settings.pass = u.pass;
          }
        }
        break;
      case Protocols.Wireguard:
        if (typeof s.mtu === "number") base.settings.mtu = s.mtu;
        if (!isEmpty(s.secretKey)) base.settings.secretKey = s.secretKey;
        if (Array.isArray(s.address)) base.settings.address = s.address.join(",");
        else if (typeof s.address === "string") base.settings.address = s.address;
        if (typeof s.workers === "number") base.settings.workers = s.workers;
        if (!isEmpty(s.domainStrategy)) base.settings.domainStrategy = s.domainStrategy;
        if (Array.isArray(s.reserved)) base.settings.reserved = s.reserved.join(",");
        else if (typeof s.reserved === "string") base.settings.reserved = s.reserved;
        if (Array.isArray(s.peers)) {
          base.settings.peers = s.peers.map(pr => ({
            publicKey: pr.publicKey || "",
            psk: pr.preSharedKey || "",
            allowedIPs: Array.isArray(pr.allowedIPs) ? pr.allowedIPs : [],
            endpoint: pr.endpoint || "",
            keepAlive: pr.keepAlive || 0
          }));
        }
        if (typeof s.noKernelTun === "boolean") base.settings.noKernelTun = s.noKernelTun;
        break;
    }
  }
  function parseStreamSettings(base, st) {
    base.streamSettings.network = st.network || "tcp";
    base.streamSettings.security = st.security || "none";
    switch (base.streamSettings.network) {
      case "tcp":
        if (st.tcpSettings && st.tcpSettings.header) {
          if (st.tcpSettings.header.type === "http") {
            base.streamSettings.tcpSettings = {
              header: {
                type: "http",
                request: {
                  headers: { Host: Array.isArray(st.tcpSettings.header.request.headers.Host) ? st.tcpSettings.header.request.headers.Host : [] },
                  path: Array.isArray(st.tcpSettings.header.request.path) ? st.tcpSettings.header.request.path : ["/"]
                },
                response: {
                  version: "1.1",
                  status: "200",
                  reason: "OK",
                  headers: {}
                }
              }
            };
          } else {
            base.streamSettings.tcpSettings = { header: { type: "none" } };
          }
        } else {
          base.streamSettings.tcpSettings = { header: { type: "none" } };
        }
        break;
      case "kcp":
        let k = st.kcpSettings || {};
        base.streamSettings.kcpSettings = {
          mtu: typeof k.mtu === "number" ? k.mtu : 1350,
          tti: typeof k.tti === "number" ? k.tti : 50,
          uplinkCapacity: typeof k.uplinkCapacity === "number" ? k.uplinkCapacity : 5,
          downlinkCapacity: typeof k.downlinkCapacity === "number" ? k.downlinkCapacity : 20,
          congestion: !!k.congestion,
          readBufferSize: typeof k.readBufferSize === "number" ? k.readBufferSize : 2,
          writeBufferSize: typeof k.writeBufferSize === "number" ? k.writeBufferSize : 2,
          header: { type: k.header && k.header.type ? k.header.type : "none" },
          seed: k.seed || ""
        };
        break;
      case "ws":
        let w = st.wsSettings || {};
        base.streamSettings.wsSettings = {
          path: w.path || "/",
          host: w.host || "",
          heartbeatPeriod: typeof w.heartbeatPeriod === "number" ? w.heartbeatPeriod : 0
        };
        break;
      case "grpc":
        let g = st.grpcSettings || {};
        base.streamSettings.grpcSettings = {
          serviceName: g.serviceName || "",
          authority: g.authority || "",
          multiMode: !!g.multiMode
        };
        break;
      case "httpupgrade":
        let hu = st.httpupgradeSettings || {};
        base.streamSettings.httpupgradeSettings = {
          path: hu.path || "/",
          host: hu.host || ""
        };
        break;
      case "xhttp":
        let xh = st.xhttpSettings || {};
        let xm = xh.xmux || {};
        base.streamSettings.xhttpSettings = {
          path: xh.path || "/",
          host: xh.host || "",
          mode: xh.mode || "auto",
          noGRPCHeader: !!xh.noGRPCHeader,
          scMinPostsIntervalMs: xh.scMinPostsIntervalMs || "30",
          xmux: {
            maxConcurrency: xm.maxConcurrency || "16-32",
            maxConnections: typeof xm.maxConnections === "number" ? xm.maxConnections : 0,
            cMaxReuseTimes: xm.cMaxReuseTimes || "0",
            hMaxRequestTimes: xm.hMaxRequestTimes || "600-900",
            hMaxReusableSecs: xm.hMaxReusableSecs || "1800-3000",
            hKeepAlivePeriod: typeof xm.hKeepAlivePeriod === "number" ? xm.hKeepAlivePeriod : 0
          }
        };
        break;
    }
    if (base.streamSettings.security === "tls") {
      let t = st.tlsSettings || {};
      base.streamSettings.tlsSettings = {
        serverName: t.serverName || "",
        alpn: Array.isArray(t.alpn) ? t.alpn : [],
        fingerprint: t.fingerprint || "",
        allowInsecure: !!t.allowInsecure
      };
    } else if (base.streamSettings.security === "reality") {
      let r = st.realitySettings || {};
      base.streamSettings.realitySettings = {
        publicKey: r.publicKey || "",
        fingerprint: r.fingerprint || "",
        serverName: r.serverName || "",
        shortId: r.shortId || "",
        spiderX: r.spiderX || "/"
      };
    }
    if (st.sockopt) {
      base.streamSettings.sockopt = {
        dialerProxy: st.sockopt.dialerProxy || "",
        tcpFastOpen: !!st.sockopt.tcpFastOpen,
        tcpKeepAliveInterval: typeof st.sockopt.tcpKeepAliveInterval === "number" ? st.sockopt.tcpKeepAliveInterval : 0,
        tcpMptcp: !!st.sockopt.tcpMptcp,
        penetrate: !!st.sockopt.penetrate
      };
    }
  }
  function parseMux(m, j) {
    if (typeof j.enabled === "boolean") m.enabled = j.enabled;
    if (typeof j.concurrency === "number") m.concurrency = j.concurrency;
    if (typeof j.xudpConcurrency === "number") m.xudpConcurrency = j.xudpConcurrency;
    if (!isEmpty(j.xudpProxyUDP443)) m.xudpProxyUDP443 = j.xudpProxyUDP443;
  }

  
  function outboundToJson(od) {
    let r = {
      protocol: od.protocol,
      tag: isEmpty(od.tag) ? undefined : od.tag
    };
    if (!isEmpty(od.sendThrough)) r.sendThrough = od.sendThrough;
    r.settings = buildSettingsJson(od.protocol, od.settings);
    if (canEnableStream(od.protocol)) {
      r.streamSettings = buildStreamSettingsJson(od.streamSettings);
    }
    if (canEnableMux(od.protocol) && od.mux && od.mux.enabled) {
      r.mux = buildMuxJson(od.mux);
    }
    for (let k in r) {
      if (r[k] === undefined) delete r[k];
    }
    return r;
  }
  function buildSettingsJson(proto, s) {
    switch (proto) {
      case Protocols.Freedom:
        return buildFreedomJson(s);
      case Protocols.Blackhole:
        return buildBlackholeJson(s);
      case Protocols.DNS:
        return buildDNSJson(s);
      case Protocols.VMess:
        return buildVMessJson(s);
      case Protocols.VLESS:
        return buildVlessJson(s);
      case Protocols.Trojan:
        return buildTrojanJson(s);
      case Protocols.Shadowsocks:
        return buildShadowsocksJson(s);
      case Protocols.Socks:
        return buildSocksJson(s);
      case Protocols.HTTP:
        return buildHttpJson(s);
      case Protocols.Wireguard:
        return buildWireguardJson(s);
      default:
        return {};
    }
  }
  function buildFreedomJson(s) {
    let r = {};
    if (!isEmpty(s.domainStrategy)) r.domainStrategy = s.domainStrategy;
    if (!isEmpty(s.redirect)) r.redirect = s.redirect;
    if (s.fragment && Object.keys(s.fragment).length > 0) {
      r.fragment = {
        packets: s.fragment.packets || "1-3",
        length: s.fragment.length || "",
        interval: s.fragment.interval || ""
      };
    }
    if (Array.isArray(s.noises) && s.noises.length > 0) {
      r.noises = s.noises.map(n => ({
        type: n.type || "rand",
        packet: n.packet || "10-20",
        delay: n.delay || "10-16"
      }));
    }
    return r;
  }
  function buildBlackholeJson(s) {
    let r = {};
    if (!isEmpty(s.type)) {
      r.response = { type: s.type };
    }
    return r;
  }
  function buildDNSJson(s) {
    let r = {
      network: s.network || "udp",
      address: s.address || "",
      port: typeof s.port === "number" ? s.port : 53,
      nonIPQuery: s.nonIPQuery || "drop"
    };
    if (Array.isArray(s.blockTypes)) r.blockTypes = s.blockTypes;
    return r;
  }
  function buildVMessJson(s) {
    return {
      vnext: [{
        address: s.address || "",
        port: typeof s.port === "number" ? s.port : 443,
        users: [{ id: s.id || "", security: s.security || "auto" }]
      }]
    };
  }
  function buildVlessJson(s) {
    return {
      vnext: [{
        address: s.address || "",
        port: typeof s.port === "number" ? s.port : 443,
        users: [{ id: s.id || "", flow: s.flow || "", encryption: "none" }]
      }]
    };
  }
  function buildTrojanJson(s) {
    return {
      servers: [{
        address: s.address || "",
        port: typeof s.port === "number" ? s.port : 443,
        password: s.password || ""
      }]
    };
  }
  function buildShadowsocksJson(s) {
    return {
      servers: [{
        address: s.address || "",
        port: typeof s.port === "number" ? s.port : 443,
        password: s.password || "",
        method: s.method || "aes-256-gcm",
        uot: !!s.uot,
        UoTVersion: typeof s.UoTVersion === "number" ? s.UoTVersion : 1
      }]
    };
  }
  function buildSocksJson(s) {
    let r = { servers: [{ address: s.address || "", port: typeof s.port === "number" ? s.port : 1080 }] };
    if (!isEmpty(s.user)) {
      r.servers[0].users = [{ user: s.user, pass: s.pass || "" }];
    }
    return r;
  }
  function buildHttpJson(s) {
    let r = { servers: [{ address: s.address || "", port: typeof s.port === "number" ? s.port : 80 }] };
    if (!isEmpty(s.user)) {
      r.servers[0].users = [{ user: s.user, pass: s.pass || "" }];
    }
    return r;
  }
  function buildWireguardJson(s) {
    let r = {
      mtu: typeof s.mtu === "number" ? s.mtu : 1420,
      secretKey: s.secretKey || "",
      address: isEmpty(s.address) ? [] : s.address.split(","),
      workers: typeof s.workers === "number" ? s.workers : 2,
      domainStrategy: isEmpty(s.domainStrategy) ? undefined : s.domainStrategy,
      reserved: isEmpty(s.reserved) ? undefined : s.reserved.split(",").map(x => +x),
      peers: [],
      noKernelTun: !!s.noKernelTun
    };
    if (Array.isArray(s.peers)) {
      r.peers = s.peers.map(p => ({
        publicKey: p.publicKey || "",
        preSharedKey: isEmpty(p.psk) ? undefined : p.psk,
        allowedIPs: Array.isArray(p.allowedIPs) ? p.allowedIPs : [],
        endpoint: p.endpoint || "",
        keepAlive: typeof p.keepAlive === "number" ? p.keepAlive : 0
      }));
    }
    return r;
  }
  function buildStreamSettingsJson(st) {
    let r = {
      network: st.network || "tcp",
      security: st.security || "none"
    };
    switch (r.network) {
      case "tcp":
        r.tcpSettings = st.tcpSettings && st.tcpSettings.header && st.tcpSettings.header.type === "http" ?
          {
            header: {
              type: "http",
              request: {
                headers: { Host: Array.isArray(st.tcpSettings.header.request.headers.Host) ? st.tcpSettings.header.request.headers.Host : [] },
                path: Array.isArray(st.tcpSettings.header.request.path) ? st.tcpSettings.header.request.path : ["/"]
              },
              response: {
                version: "1.1",
                status: "200",
                reason: "OK",
                headers: {}
              }
            }
          } : { header: { type: "none" } };
        break;
      case "kcp":
        let k = st.kcpSettings || {};
        r.kcpSettings = {
          mtu: typeof k.mtu === "number" ? k.mtu : 1350,
          tti: typeof k.tti === "number" ? k.tti : 50,
          uplinkCapacity: typeof k.uplinkCapacity === "number" ? k.uplinkCapacity : 5,
          downlinkCapacity: typeof k.downlinkCapacity === "number" ? k.downlinkCapacity : 20,
          congestion: !!k.congestion,
          readBufferSize: typeof k.readBufferSize === "number" ? k.readBufferSize : 2,
          writeBufferSize: typeof k.writeBufferSize === "number" ? k.writeBufferSize : 2,
          header: { type: k.header && k.header.type ? k.header.type : "none" },
          seed: k.seed || ""
        };
        break;
      case "ws":
        let w = st.wsSettings || {};
        r.wsSettings = {
          path: w.path || "/",
          host: w.host || "",
          heartbeatPeriod: typeof w.heartbeatPeriod === "number" ? w.heartbeatPeriod : 0
        };
        break;
      case "grpc":
        let g = st.grpcSettings || {};
        r.grpcSettings = {
          serviceName: g.serviceName || "",
          authority: g.authority || "",
          multiMode: !!g.multiMode
        };
        break;
      case "httpupgrade":
        let hu = st.httpupgradeSettings || {};
        r.httpupgradeSettings = {
          path: hu.path || "/",
          host: hu.host || ""
        };
        break;
      case "xhttp":
        let xh = st.xhttpSettings || {};
        let xm = xh.xmux || {};
        r.xhttpSettings = {
          path: xh.path || "/",
          host: xh.host || "",
          mode: xh.mode || "auto",
          noGRPCHeader: !!xh.noGRPCHeader,
          scMinPostsIntervalMs: xh.scMinPostsIntervalMs || "30",
          xmux: {
            maxConcurrency: xm.maxConcurrency || "16-32",
            maxConnections: typeof xm.maxConnections === "number" ? xm.maxConnections : 0,
            cMaxReuseTimes: xm.cMaxReuseTimes || "0",
            hMaxRequestTimes: xm.hMaxRequestTimes || "600-900",
            hMaxReusableSecs: xm.hMaxReusableSecs || "1800-3000",
            hKeepAlivePeriod: typeof xm.hKeepAlivePeriod === "number" ? xm.hKeepAlivePeriod : 0
          }
        };
        break;
    }
    if (r.security === "tls") {
      let t = st.tlsSettings || {};
      r.tlsSettings = {
        serverName: t.serverName || "",
        alpn: Array.isArray(t.alpn) ? t.alpn : [],
        fingerprint: t.fingerprint || "",
        allowInsecure: !!t.allowInsecure
      };
    } else if (r.security === "reality") {
      let rr = st.realitySettings || {};
      r.realitySettings = {
        publicKey: rr.publicKey || "",
        fingerprint: rr.fingerprint || "",
        serverName: rr.serverName || "",
        shortId: rr.shortId || "",
        spiderX: rr.spiderX || "/"
      };
    }
    if (st.sockopt) {
      r.sockopt = {
        dialerProxy: st.sockopt.dialerProxy || "",
        tcpFastOpen: !!st.sockopt.tcpFastOpen,
        tcpKeepAliveInterval: typeof st.sockopt.tcpKeepAliveInterval === "number" ? st.sockopt.tcpKeepAliveInterval : 0,
        tcpMptcp: !!st.sockopt.tcpMptcp,
        penetrate: !!st.sockopt.penetrate
      };
    }
    return r;
  }
  function buildMuxJson(m) {
    return {
      enabled: !!m.enabled,
      concurrency: typeof m.concurrency === "number" ? m.concurrency : 8,
      xudpConcurrency: typeof m.xudpConcurrency === "number" ? m.xudpConcurrency : 16,
      xudpProxyUDP443: isEmpty(m.xudpProxyUDP443) ? "reject" : m.xudpProxyUDP443
    };
  }

  
  function fillFormFromOutbound() {
    if (!outboundData) return;
    document.getElementById("protocolSelect").value = outboundData.protocol;
    document.getElementById("tagInput").value = outboundData.tag || "";
    document.getElementById("sendThroughInput").value = outboundData.sendThrough || "";
    checkDuplicateTag();
    toggleSections();
    fillProtocolSpecific();
    if (canEnableStream(outboundData.protocol)) fillStreamUI();
    if (canEnableTls(outboundData.protocol)) fillTLSUI();
    fillSockoptUI();
    fillMuxUI();
  }
  function toggleSections() {
    let sections = [
      "freedomSection", "blackholeSection", "dnsSection", "wireguardSection",
      "addressPortSection", "vnextSection", "serversSection", "streamSection", "tlsSection",
      "sockoptSection", "muxSection"
    ];
    sections.forEach(id => document.getElementById(id).classList.add("hidden"));
    switch (outboundData.protocol) {
      case Protocols.Freedom:
        document.getElementById("freedomSection").classList.remove("hidden");
        break;
      case Protocols.Blackhole:
        document.getElementById("blackholeSection").classList.remove("hidden");
        break;
      case Protocols.DNS:
        document.getElementById("dnsSection").classList.remove("hidden");
        break;
      case Protocols.Wireguard:
        document.getElementById("wireguardSection").classList.remove("hidden");
        break;
    }
    if (hasAddressPort(outboundData.protocol)) {
      document.getElementById("addressPortSection").classList.remove("hidden");
    }
    if ([Protocols.VMess, Protocols.VLESS].includes(outboundData.protocol)) {
      document.getElementById("vnextSection").classList.remove("hidden");
    }
    if (hasServers(outboundData.protocol)) {
      document.getElementById("serversSection").classList.remove("hidden");
    }
    if (canEnableStream(outboundData.protocol)) {
      document.getElementById("streamSection").classList.remove("hidden");
    }
    if (canEnableTls(outboundData.protocol)) {
      document.getElementById("tlsSection").classList.remove("hidden");
    }
    
    if (canEnableStream(outboundData.protocol)) {
      document.getElementById("sockoptSection").classList.remove("hidden");
    } else {
      document.getElementById("sockoptSection").classList.add("hidden");
    }
    if (canEnableMux(outboundData.protocol)) {
      document.getElementById("muxSection").classList.remove("hidden");
    }
  }
  function hasAddressPort(proto) {
    return [Protocols.DNS, Protocols.VMess, Protocols.VLESS, Protocols.Trojan,
      Protocols.Shadowsocks, Protocols.Socks, Protocols.HTTP].includes(proto);
  }
  function hasServers(proto) {
    return [Protocols.Trojan, Protocols.Shadowsocks, Protocols.Socks, Protocols.HTTP].includes(proto);
  }
  function canEnableTls(proto) {
    return [Protocols.VMess, Protocols.VLESS, Protocols.Trojan, Protocols.Shadowsocks].includes(proto);
  }
  function canEnableStream(proto) {
    return [Protocols.VMess, Protocols.VLESS, Protocols.Trojan, Protocols.Shadowsocks].includes(proto);
  }
  function canEnableMux(proto) {
    return [Protocols.VMess, Protocols.VLESS, Protocols.Trojan, Protocols.Shadowsocks, Protocols.HTTP, Protocols.Socks].includes(proto);
  }
  function fillProtocolSpecific() {
    let proto = outboundData.protocol;
    let s = outboundData.settings;
    if (proto === Protocols.Freedom) {
      document.getElementById("freedomDomainStrategy").value = s.domainStrategy || "";
      document.getElementById("freedomRedirect").value = s.redirect || "";
      let fragOn = (s.fragment && Object.keys(s.fragment).length > 0);
      document.getElementById("freedomFragmentEnable").checked = fragOn;
      if (fragOn) {
        document.getElementById("freedomFragmentFields").classList.remove("hidden");
        document.getElementById("freedomFragmentPackets").value = s.fragment.packets || "1-3";
        document.getElementById("freedomFragmentLength").value = s.fragment.length || "";
        document.getElementById("freedomFragmentInterval").value = s.fragment.interval || "";
      } else {
        document.getElementById("freedomFragmentFields").classList.add("hidden");
      }
      let nzArr = s.noises || [];
      document.getElementById("freedomNoisesEnable").checked = (nzArr.length > 0);
      if (nzArr.length > 0) {
        document.getElementById("freedomNoisesContainer").classList.remove("hidden");
        buildFreedomNoisesList();
      } else {
        document.getElementById("freedomNoisesContainer").classList.add("hidden");
        document.getElementById("freedomNoisesList").innerHTML = "";
      }
    }
    if (proto === Protocols.Blackhole) {
      document.getElementById("blackholeType").value = s.type || "";
    }
    if (proto === Protocols.DNS) {
      document.getElementById("dnsNetwork").value = s.network || "udp";
      document.getElementById("dnsNonIPQuery").value = s.nonIPQuery || "drop";
      document.getElementById("dnsBlockTypes").value = (s.blockTypes && s.blockTypes[0]) || "0";
      toggleDNSBlockTypes();
    }
    if (proto === Protocols.Wireguard) {
      document.getElementById("wgAddress").value = s.address || "";
      document.getElementById("wgSecretKey").value = s.secretKey || "";
      document.getElementById("wgPubKey").value = s.pubKey || "";
      document.getElementById("wgDomainStrategy").value = s.domainStrategy || "";
      document.getElementById("wgMTU").value = s.mtu || 1420;
      document.getElementById("wgWorkers").value = s.workers || 2;
      document.getElementById("wgNoKernelTun").checked = s.noKernelTun || false;
      document.getElementById("wgReserved").value = s.reserved || "";
      buildWireguardPeersList();
    }
    if (hasAddressPort(proto)) {
      document.getElementById("apAddress").value = s.address || "";
      document.getElementById("apPort").value = s.port || 443;
    }
    if ([Protocols.VMess, Protocols.VLESS].includes(proto)) {
      if (proto === Protocols.VMess) {
        document.getElementById("vmessSecurityRow").classList.remove("hidden");
        document.getElementById("vlessFlowRow").classList.add("hidden");
        document.getElementById("vnextID").value = s.id || "";
        document.getElementById("vmessSecurity").value = s.security || "auto";
      } else {
        document.getElementById("vmessSecurityRow").classList.add("hidden");
        document.getElementById("vlessFlowRow").classList.remove("hidden");
        document.getElementById("vnextID").value = s.id || "";
        document.getElementById("vlessFlow").value = s.flow || "";
      }
    } else {
      document.getElementById("vmessSecurityRow").classList.add("hidden");
      document.getElementById("vlessFlowRow").classList.add("hidden");
    }
    if (hasServers(proto)) {
      let showUserPass = ([Protocols.Socks, Protocols.HTTP].includes(proto));
      let showTrojanSS = ([Protocols.Trojan, Protocols.Shadowsocks].includes(proto));
      if (showUserPass) {
        document.getElementById("srvUserRow").classList.remove("hidden");
        document.getElementById("srvPassRow").classList.remove("hidden");
        document.getElementById("srvUser").value = s.user || "";
        document.getElementById("srvPass").value = s.pass || "";
      } else {
        document.getElementById("srvUserRow").classList.add("hidden");
        document.getElementById("srvPassRow").classList.add("hidden");
      }
      if (showTrojanSS) {
        document.getElementById("srvSSPassRow").classList.remove("hidden");
        document.getElementById("srvSSPassword").value = s.password || "";
      } else {
        document.getElementById("srvSSPassRow").classList.add("hidden");
      }
      if (proto === Protocols.Shadowsocks) {
        document.getElementById("ssMethodRow").classList.remove("hidden");
        document.getElementById("ssUotRow").classList.remove("hidden");
        document.getElementById("ssUotVersionRow").classList.remove("hidden");
        document.getElementById("ssMethod").value = s.method || "aes-256-gcm";
        document.getElementById("ssUot").checked = s.uot || false;
        document.getElementById("ssUotVersion").value = s.UoTVersion || 1;
      } else {
        document.getElementById("ssMethodRow").classList.add("hidden");
        document.getElementById("ssUotRow").classList.add("hidden");
        document.getElementById("ssUotVersionRow").classList.add("hidden");
      }
    } else {
      document.getElementById("srvUserRow").classList.add("hidden");
      document.getElementById("srvPassRow").classList.add("hidden");
      document.getElementById("srvSSPassRow").classList.add("hidden");
      document.getElementById("ssMethodRow").classList.add("hidden");
      document.getElementById("ssUotRow").classList.add("hidden");
      document.getElementById("ssUotVersionRow").classList.add("hidden");
    }
  }
  function toggleDNSBlockTypes() {
    let v = document.getElementById("dnsNonIPQuery").value;
    if (v === "skip")
      document.getElementById("dnsBlockTypesRow").classList.remove("hidden");
    else
      document.getElementById("dnsBlockTypesRow").classList.add("hidden");
  }
  function buildFreedomNoisesList() {
    let arr = outboundData.settings.noises || [];
    let cont = document.getElementById("freedomNoisesList");
    cont.innerHTML = "";
    arr.forEach((nz, idx) => {
      let div = document.createElement("div");
      div.className = "noise-block";
      div.innerHTML = `
        <div class="divider">Noise #${idx + 1}</div>
        <div>
          <label>Type:</label>
          <select data-idx="${idx}" data-field="type" style="width:80px;">
            <option value="rand">rand</option>
            <option value="base64">base64</option>
            <option value="str">str</option>
          </select>
        </div>
        <div>
          <label>Packet:</label>
          <input type="text" data-idx="${idx}" data-field="packet" style="width:80px;">
        </div>
        <div>
          <label>Delay:</label>
          <input type="text" data-idx="${idx}" data-field="delay" style="width:80px;">
        </div>
        <button class="btn btn-sm btn-danger" onclick="removeFreedomNoise(${idx})">Remove</button>
      `;
      cont.appendChild(div);
      let sel = div.querySelector('select[data-field="type"]');
      sel.value = nz.type || "rand";
      sel.addEventListener("change", onFreedomNoiseChange);
      let p1 = div.querySelector('input[data-field="packet"]');
      p1.value = nz.packet || "10-20";
      p1.addEventListener("input", onFreedomNoiseChange);
      let p2 = div.querySelector('input[data-field="delay"]');
      p2.value = nz.delay || "10-16";
      p2.addEventListener("input", onFreedomNoiseChange);
    });
  }
  function onFreedomNoiseChange(e) {
    let idx = parseInt(e.target.getAttribute("data-idx"));
    let field = e.target.getAttribute("data-field");
    outboundData.settings.noises[idx][field] = e.target.value;
    syncFormToJson();
  }
  function addFreedomNoise() {
    outboundData.settings.noises.push({ type: "rand", packet: "10-20", delay: "10-16" });
    buildFreedomNoisesList();
    syncFormToJson();
  }
  function removeFreedomNoise(idx) {
    outboundData.settings.noises.splice(idx, 1);
    buildFreedomNoisesList();
    syncFormToJson();
  }
  function buildWireguardPeersList() {
    let arr = outboundData.settings.peers || [];
    let cont = document.getElementById("wgPeersContainer");
    cont.innerHTML = "";
    arr.forEach((p, idx) => {
      let div = document.createElement("div");
      div.className = "peer-block";
      div.innerHTML = `
        <div class="divider">Peer #${idx + 1}
          <button class="btn btn-sm btn-danger" onclick="removeWireguardPeer(${idx})">Delete Peer</button>
        </div>
        <div>
          <label>Endpoint:</label>
          <input type="text" data-pidx="${idx}" data-field="endpoint">
        </div>
        <div>
          <label>PublicKey:</label>
          <input type="text" data-pidx="${idx}" data-field="publicKey">
        </div>
        <div>
          <label>PSK:</label>
          <input type="text" data-pidx="${idx}" data-field="psk">
        </div>
        <div>
          <label>AllowedIPs:</label>
          <button class="btn btn-sm" onclick="addWireguardPeerAllowedIp(${idx})">+</button>
          <div id="peer${idx}AllowedIPs"></div>
        </div>
        <div>
          <label>KeepAlive:</label>
          <input type="number" data-pidx="${idx}" data-field="keepAlive">
        </div>
      `;
      cont.appendChild(div);
      let e1 = div.querySelector('input[data-field="endpoint"]');
      e1.value = p.endpoint || "";
      e1.addEventListener("input", onWireguardPeerChange);
      let e2 = div.querySelector('input[data-field="publicKey"]');
      e2.value = p.publicKey || "";
      e2.addEventListener("input", onWireguardPeerChange);
      let e3 = div.querySelector('input[data-field="psk"]');
      e3.value = p.psk || "";
      e3.addEventListener("input", onWireguardPeerChange);
      let e4 = div.querySelector('input[data-field="keepAlive"]');
      e4.value = p.keepAlive || 0;
      e4.addEventListener("input", onWireguardPeerChange);
      buildWireguardPeerAllowedIPs(idx);
    });
  }
  function onWireguardPeerChange(e) {
    let idx = parseInt(e.target.getAttribute("data-pidx"));
    let field = e.target.getAttribute("data-field");
    outboundData.settings.peers[idx][field] = e.target.value;
    syncFormToJson();
  }
  function removeWireguardPeer(idx) {
    outboundData.settings.peers.splice(idx, 1);
    buildWireguardPeersList();
    syncFormToJson();
  }
  function addWireguardPeer() {
    outboundData.settings.peers.push({
      publicKey: "",
      psk: "",
      allowedIPs: ["0.0.0.0/0", "::/0"],
      endpoint: "",
      keepAlive: 0
    });
    buildWireguardPeersList();
    syncFormToJson();
  }
  function buildWireguardPeerAllowedIPs(pIdx) {
    let arr = outboundData.settings.peers[pIdx].allowedIPs || [];
    let cont = document.getElementById(`peer${pIdx}AllowedIPs`);
    cont.innerHTML = "";
    arr.forEach((ip, ipIdx) => {
      let row = document.createElement("div");
      row.className = "form-row";
      row.innerHTML = `
        <input type="text" style="width:160px;" value="${ip}" data-pidx="${pIdx}" data-ipidx="${ipIdx}">
        <button class="btn btn-sm btn-danger" onclick="removeWireguardAllowedIp(${pIdx}, ${ipIdx})">-</button>
      `;
      cont.appendChild(row);
      let inp = row.querySelector("input");
      inp.addEventListener("input", (ev) => {
        outboundData.settings.peers[pIdx].allowedIPs[ipIdx] = ev.target.value;
        syncFormToJson();
      });
    });
  }
  function removeWireguardAllowedIp(pIdx, ipIdx) {
    outboundData.settings.peers[pIdx].allowedIPs.splice(ipIdx, 1);
    buildWireguardPeersList();
    syncFormToJson();
  }
  function addWireguardPeerAllowedIp(pIdx) {
    outboundData.settings.peers[pIdx].allowedIPs.push("");
    buildWireguardPeersList();
    syncFormToJson();
  }
  function regenWireguardKeypair() {
    outboundData.settings.secretKey = "AutoSecret_" + Math.random().toString(16).substring(2, 6);
    outboundData.settings.pubKey = "AutoPubKeyForDemo";
    buildWireguardPeersList();
    syncFormToJson();
  }
  function fillStreamUI() {
    let st = outboundData.streamSettings || {};
    document.getElementById("streamNetwork").value = st.network || "tcp";
    ["tcpSection", "kcpSection", "wsSection", "grpcSection", "httpupgradeSection", "xhttpSection"]
      .forEach(id => document.getElementById(id).classList.add("hidden"));
    switch (st.network) {
      case "tcp":
        document.getElementById("tcpSection").classList.remove("hidden");
        if (st.tcpSettings && st.tcpSettings.header && st.tcpSettings.header.type === "http") {
          document.getElementById("tcpHTTPEnable").checked = true;
          document.getElementById("tcpHTTPFields").classList.remove("hidden");
          let hosts = (st.tcpSettings.header.request.headers.Host || []).join(",");
          let paths = (st.tcpSettings.header.request.path || ["/"]).join(",");
          document.getElementById("tcpHTTPHost").value = hosts;
          document.getElementById("tcpHTTPPath").value = paths;
        } else {
          document.getElementById("tcpHTTPEnable").checked = false;
          document.getElementById("tcpHTTPFields").classList.add("hidden");
        }
        break;
      case "kcp":
        document.getElementById("kcpSection").classList.remove("hidden");
        let k = st.kcpSettings || {};
        document.getElementById("kcpType").value = k.header ? k.header.type : "none";
        document.getElementById("kcpSeed").value = k.seed || "";
        document.getElementById("kcpMTU").value = k.mtu || 1350;
        document.getElementById("kcpTTI").value = k.tti || 50;
        document.getElementById("kcpUpCap").value = k.uplinkCapacity || 5;
        document.getElementById("kcpDownCap").value = k.downlinkCapacity || 20;
        document.getElementById("kcpCongestion").checked = !!k.congestion;
        document.getElementById("kcpReadBuffer").value = k.readBufferSize || 2;
        document.getElementById("kcpWriteBuffer").value = k.writeBufferSize || 2;
        break;
      case "ws":
        document.getElementById("wsSection").classList.remove("hidden");
        let w = st.wsSettings || {};
        document.getElementById("wsHost").value = w.host || "";
        document.getElementById("wsPath").value = w.path || "/";
        document.getElementById("wsHeartbeat").value = w.heartbeatPeriod || 0;
        break;
      case "grpc":
        document.getElementById("grpcSection").classList.remove("hidden");
        let g = st.grpcSettings || {};
        document.getElementById("grpcServiceName").value = g.serviceName || "";
        document.getElementById("grpcAuthority").value = g.authority || "";
        document.getElementById("grpcMultiMode").checked = !!g.multiMode;
        break;
      case "httpupgrade":
        document.getElementById("httpupgradeSection").classList.remove("hidden");
        let hu = st.httpupgradeSettings || {};
        document.getElementById("httpupgradeHost").value = hu.host || "";
        document.getElementById("httpupgradePath").value = hu.path || "/";
        break;
      case "xhttp":
        document.getElementById("xhttpSection").classList.remove("hidden");
        let xh = st.xhttpSettings || {};
        document.getElementById("xhttpHost").value = xh.host || "";
        document.getElementById("xhttpPath").value = xh.path || "/";
        document.getElementById("xhttpMode").value = xh.mode || "auto";
        document.getElementById("xhttpNoGRPCHeader").checked = !!xh.noGRPCHeader;
        document.getElementById("xhttpScMinPostsIntervalMs").value = xh.scMinPostsIntervalMs || "30";
        let xm = xh.xmux || {};
        document.getElementById("xhttpMaxConcurrency").value = xm.maxConcurrency || "16-32";
        document.getElementById("xhttpMaxConnections").value = xm.maxConnections || 0;
        document.getElementById("xhttpCMaxReuseTimes").value = xm.cMaxReuseTimes || "0";
        document.getElementById("xhttpHMaxRequestTimes").value = xm.hMaxRequestTimes || "600-900";
        document.getElementById("xhttpHMaxReusableSecs").value = xm.hMaxReusableSecs || "1800-3000";
        document.getElementById("xhttpHKeepAlivePeriod").value = xm.hKeepAlivePeriod || 0;
        break;
    }
  }
  function fillTLSUI() {
    let st = outboundData.streamSettings || {};
    let sec = st.security || "none";
    document.getElementById("tlsSecurity").value = sec;
    if (sec === "tls") {
      document.getElementById("tlsFields").classList.remove("hidden");
      document.getElementById("realityFields").classList.add("hidden");
      let t = st.tlsSettings || {};
      document.getElementById("tlsServerName").value = t.serverName || "";
      document.getElementById("tlsFingerprintSelect").value = t.fingerprint || "";
      document.getElementById("tlsAlpnInput").value = Array.isArray(t.alpn) ? t.alpn.join(",") : "";
      document.getElementById("tlsAllowInsecure").checked = !!t.allowInsecure;
    } else if (sec === "reality") {
      document.getElementById("tlsFields").classList.add("hidden");
      document.getElementById("realityFields").classList.remove("hidden");
      let r = st.realitySettings || {};
      document.getElementById("realityServerName").value = r.serverName || "";
      document.getElementById("realityFingerprintSelect").value = r.fingerprint || "";
      document.getElementById("realityShortId").value = r.shortId || "";
      document.getElementById("realitySpiderX").value = r.spiderX || "/";
      document.getElementById("realityPublicKey").value = r.publicKey || "";
    } else {
      document.getElementById("tlsFields").classList.add("hidden");
      document.getElementById("realityFields").classList.add("hidden");
    }
  }
  function fillSockoptUI() {
    
    if (!canEnableStream(outboundData.protocol)) {
      document.getElementById("sockoptSection").classList.add("hidden");
      return;
    }
    let st = outboundData.streamSettings || {};
    if (st.sockopt) {
      document.getElementById("sockoptEnable").checked = true;
      document.getElementById("sockoptFields").classList.remove("hidden");
      document.getElementById("sockoptDialerProxy").value = st.sockopt.dialerProxy || "";
      document.getElementById("sockoptTcpFastOpen").checked = !!st.sockopt.tcpFastOpen;
      document.getElementById("sockoptTcpKeepAliveInterval").value = st.sockopt.tcpKeepAliveInterval || 0;
      document.getElementById("sockoptTcpMptcp").checked = !!st.sockopt.tcpMptcp;
      document.getElementById("sockoptPenetrate").checked = !!st.sockopt.penetrate;
    } else {
      document.getElementById("sockoptEnable").checked = false;
      document.getElementById("sockoptFields").classList.add("hidden");
    }
  }
  function fillMuxUI() {
    if (!canEnableMux(outboundData.protocol)) {
      document.getElementById("muxSection").classList.add("hidden");
      return;
    }
    let m = outboundData.mux || {};
    document.getElementById("muxEnable").checked = !!m.enabled;
    if (m.enabled) {
      document.getElementById("muxFields").classList.remove("hidden");
      document.getElementById("muxConcurrency").value = m.concurrency || 8;
      document.getElementById("muxXudpConcurrency").value = m.xudpConcurrency || 16;
      document.getElementById("muxXudpProxyUDP443").value = m.xudpProxyUDP443 || "reject";
    } else {
      document.getElementById("muxFields").classList.add("hidden");
    }
  }

  
  function attachFormListeners() {
    let inputs = document.querySelectorAll("#formTab input, #formTab select");
    inputs.forEach(el => {
      el.addEventListener("input", () => syncFormToJson());
      el.addEventListener("change", () => syncFormToJson());
    });
  }
  function syncFormToJson() {
    if (isFormUpdateInProgress) return;
    isEditorUpdateInProgress = true;
    readFormIntoOutbound();
    let finalObj = outboundToJson(outboundData);
    cmEditor.setValue(JSON.stringify(finalObj, null, 2));
    isEditorUpdateInProgress = false;
  }
  function readFormIntoOutbound() {
    let proto = document.getElementById("protocolSelect").value;
    outboundData.protocol = proto;
    
    if (canEnableStream(proto) && !outboundData.streamSettings) {
      outboundData.streamSettings = {};
    }
    outboundData.tag = document.getElementById("tagInput").value.trim();
    outboundData.sendThrough = document.getElementById("sendThroughInput").value.trim();
    if (proto === Protocols.Freedom) {
      outboundData.settings.domainStrategy = document.getElementById("freedomDomainStrategy").value;
      outboundData.settings.redirect = document.getElementById("freedomRedirect").value;
      let fragOn = document.getElementById("freedomFragmentEnable").checked;
      outboundData.settings.fragment = fragOn ? {
        packets: document.getElementById("freedomFragmentPackets").value,
        length: document.getElementById("freedomFragmentLength").value,
        interval: document.getElementById("freedomFragmentInterval").value
      } : {};
      let noiseOn = document.getElementById("freedomNoisesEnable").checked;
      if (!noiseOn) outboundData.settings.noises = [];
    }
    if (proto === Protocols.Blackhole) {
      outboundData.settings.type = document.getElementById("blackholeType").value;
    }
    if (proto === Protocols.DNS) {
      outboundData.settings.network = document.getElementById("dnsNetwork").value;
      outboundData.settings.nonIPQuery = document.getElementById("dnsNonIPQuery").value;
      let bt = parseInt(document.getElementById("dnsBlockTypes").value || "0");
      outboundData.settings.blockTypes = [bt];
    }
    if (proto === Protocols.Wireguard) {
      outboundData.settings.address = document.getElementById("wgAddress").value;
      outboundData.settings.secretKey = document.getElementById("wgSecretKey").value;
      outboundData.settings.pubKey = document.getElementById("wgPubKey").value;
      outboundData.settings.domainStrategy = document.getElementById("wgDomainStrategy").value;
      outboundData.settings.mtu = parseInt(document.getElementById("wgMTU").value || "1420");
      outboundData.settings.workers = parseInt(document.getElementById("wgWorkers").value || "2");
      outboundData.settings.noKernelTun = document.getElementById("wgNoKernelTun").checked;
      outboundData.settings.reserved = document.getElementById("wgReserved").value;
    }
    if (hasAddressPort(proto)) {
      outboundData.settings.address = document.getElementById("apAddress").value;
      outboundData.settings.port = parseInt(document.getElementById("apPort").value || "443");
    }
    if ([Protocols.VMess, Protocols.VLESS].includes(proto)) {
      if (proto === Protocols.VMess) {
        outboundData.settings.id = document.getElementById("vnextID").value;
        outboundData.settings.security = document.getElementById("vmessSecurity").value;
      } else {
        outboundData.settings.id = document.getElementById("vnextID").value;
        outboundData.settings.flow = document.getElementById("vlessFlow").value;
      }
    }
    if (hasServers(proto)) {
      if ([Protocols.Socks, Protocols.HTTP].includes(proto)) {
        outboundData.settings.user = document.getElementById("srvUser").value;
        outboundData.settings.pass = document.getElementById("srvPass").value;
      }
      if ([Protocols.Trojan, Protocols.Shadowsocks].includes(proto)) {
        outboundData.settings.password = document.getElementById("srvSSPassword").value;
      }
      if (proto === Protocols.Shadowsocks) {
        outboundData.settings.method = document.getElementById("ssMethod").value;
        outboundData.settings.uot = document.getElementById("ssUot").checked;
        outboundData.settings.UoTVersion = parseInt(document.getElementById("ssUotVersion").value || "1");
      }
    }
    if (canEnableStream(proto)) {
      let st = outboundData.streamSettings;
      st.network = document.getElementById("streamNetwork").value;
      if (st.network === "tcp") {
        let httpOn = document.getElementById("tcpHTTPEnable").checked;
        st.tcpSettings = httpOn ? {
          header: {
            type: "http",
            request: {
              headers: { Host: isEmpty(document.getElementById("tcpHTTPHost").value) ? [] : document.getElementById("tcpHTTPHost").value.split(",") },
              path: isEmpty(document.getElementById("tcpHTTPPath").value) ? ["/"] : document.getElementById("tcpHTTPPath").value.split(",")
            },
            response: {
              version: "1.1",
              status: "200",
              reason: "OK",
              headers: {}
            }
          }
        } : { header: { type: "none" } };
      }
      if (st.network === "kcp") {
        st.kcpSettings = {
          header: { type: document.getElementById("kcpType").value },
          seed: document.getElementById("kcpSeed").value,
          mtu: parseInt(document.getElementById("kcpMTU").value || "1350"),
          tti: parseInt(document.getElementById("kcpTTI").value || "50"),
          uplinkCapacity: parseInt(document.getElementById("kcpUpCap").value || "5"),
          downlinkCapacity: parseInt(document.getElementById("kcpDownCap").value || "20"),
          congestion: document.getElementById("kcpCongestion").checked,
          readBufferSize: parseInt(document.getElementById("kcpReadBuffer").value || "2"),
          writeBufferSize: parseInt(document.getElementById("kcpWriteBuffer").value || "2")
        };
      }
      if (st.network === "ws") {
        st.wsSettings = {
          host: document.getElementById("wsHost").value,
          path: document.getElementById("wsPath").value,
          heartbeatPeriod: parseInt(document.getElementById("wsHeartbeat").value || "0")
        };
      }
      if (st.network === "grpc") {
        st.grpcSettings = {
          serviceName: document.getElementById("grpcServiceName").value,
          authority: document.getElementById("grpcAuthority").value,
          multiMode: document.getElementById("grpcMultiMode").checked
        };
      }
      if (st.network === "httpupgrade") {
        st.httpupgradeSettings = {
          host: document.getElementById("httpupgradeHost").value,
          path: document.getElementById("httpupgradePath").value
        };
      }
      if (st.network === "xhttp") {
        st.xhttpSettings = {
          host: document.getElementById("xhttpHost").value,
          path: document.getElementById("xhttpPath").value,
          mode: document.getElementById("xhttpMode").value,
          noGRPCHeader: document.getElementById("xhttpNoGRPCHeader").checked,
          scMinPostsIntervalMs: document.getElementById("xhttpScMinPostsIntervalMs").value,
          xmux: {
            maxConcurrency: document.getElementById("xhttpMaxConcurrency").value,
            maxConnections: parseInt(document.getElementById("xhttpMaxConnections").value || "0"),
            cMaxReuseTimes: document.getElementById("xhttpCMaxReuseTimes").value,
            hMaxRequestTimes: document.getElementById("xhttpHMaxRequestTimes").value,
            hMaxReusableSecs: document.getElementById("xhttpHMaxReusableSecs").value,
            hKeepAlivePeriod: parseInt(document.getElementById("xhttpHKeepAlivePeriod").value || "0")
          }
        };
      }
      st.security = document.getElementById("tlsSecurity").value;
      if (st.security === "tls") {
        st.tlsSettings = {
          serverName: document.getElementById("tlsServerName").value,
          fingerprint: document.getElementById("tlsFingerprintSelect").value,
          alpn: isEmpty(document.getElementById("tlsAlpnInput").value) ? [] : document.getElementById("tlsAlpnInput").value.split(",").map(x => x.trim()),
          allowInsecure: document.getElementById("tlsAllowInsecure").checked
        };
      } else if (st.security === "reality") {
        st.realitySettings = {
          serverName: document.getElementById("realityServerName").value,
          fingerprint: document.getElementById("realityFingerprintSelect").value,
          shortId: document.getElementById("realityShortId").value,
          spiderX: document.getElementById("realitySpiderX").value,
          publicKey: document.getElementById("realityPublicKey").value
        };
      }
    }
    let soEnabled = document.getElementById("sockoptEnable").checked;
    if (soEnabled && canEnableStream(proto)) {
      outboundData.streamSettings.sockopt = {
        dialerProxy: document.getElementById("sockoptDialerProxy").value,
        tcpFastOpen: document.getElementById("sockoptTcpFastOpen").checked,
        tcpKeepAliveInterval: parseInt(document.getElementById("sockoptTcpKeepAliveInterval").value || "0"),
        tcpMptcp: document.getElementById("sockoptTcpMptcp").checked,
        penetrate: document.getElementById("sockoptPenetrate").checked
      };
    } else if (canEnableStream(proto)) {
      outboundData.streamSettings.sockopt = undefined;
    }
    if (canEnableMux(proto)) {
      if (!outboundData.mux) outboundData.mux = { enabled: false, concurrency: 8, xudpConcurrency: 16, xudpProxyUDP443: "reject" };
      let muxOn = document.getElementById("muxEnable").checked;
      outboundData.mux.enabled = muxOn;
      if (muxOn) {
        outboundData.mux.concurrency = parseInt(document.getElementById("muxConcurrency").value || "8");
        outboundData.mux.xudpConcurrency = parseInt(document.getElementById("muxXudpConcurrency").value || "16");
        outboundData.mux.xudpProxyUDP443 = document.getElementById("muxXudpProxyUDP443").value;
      }
    } else {
      outboundData.mux = undefined;
    }
  }

  
  let existingTags = ["outTag", "sampleTag", "defaultTag"];
  function checkDuplicateTag() {
    let t = document.getElementById("tagInput").value.trim();
    if (!t || existingTags.includes(t)) {
      document.getElementById("tagWarning").style.display = "";
    } else {
      document.getElementById("tagWarning").style.display = "none";
    }
  }

  
  function switchTab(tab) {
    document.getElementById("formTabBtn").classList.remove("active");
    document.getElementById("jsonTabBtn").classList.remove("active");
    document.getElementById("formTab").classList.add("hidden");
    document.getElementById("jsonTab").classList.add("hidden");
    if (tab === "form") {
      currentTab = "form";
      document.getElementById("formTabBtn").classList.add("active");
      document.getElementById("formTab").classList.remove("hidden");
    } else {
      currentTab = "json";
      document.getElementById("jsonTabBtn").classList.add("active");
      document.getElementById("jsonTab").classList.remove("hidden");
      syncFormToJson();
    }
  }

  
  function initSelectOptions() {
    let ps = document.getElementById("protocolSelect");
    for (let k in Protocols) {
      let val = Protocols[k];
      let opt = document.createElement("option");
      opt.value = val;
      opt.textContent = k;
      ps.appendChild(opt);
    }
    let fds = document.getElementById("freedomDomainStrategy");
    ["AsIs", "UseIP", "UseIPv4", "UseIPv6", "UseIPv6v4", "UseIPv4v6", "ForceIP", "ForceIPv6v4", "ForceIPv6", "ForceIPv4v6", "ForceIPv4"].forEach(fd => {
      let o = document.createElement("option");
      o.value = fd;
      o.textContent = fd;
      fds.appendChild(o);
    });
    let wds = document.getElementById("wgDomainStrategy");
    ["ForceIP", "ForceIPv4", "ForceIPv4v6", "ForceIPv6", "ForceIPv6v4"].forEach(x => {
      let o = document.createElement("option");
      o.value = x;
      o.textContent = x;
      wds.appendChild(o);
    });
    let vs = document.getElementById("vmessSecurity");
    ["aes-128-gcm", "chacha20-poly1305", "auto", "none", "zero"].forEach(sec => {
      let o = document.createElement("option");
      o.value = sec;
      o.textContent = sec;
      vs.appendChild(o);
    });
    let ssm = document.getElementById("ssMethod");
    ["aes-256-gcm", "aes-128-gcm", "chacha20-poly1305", "chacha20-ietf-poly1305",
      "xchacha20-poly1305", "xchacha20-ietf-poly1305", "2022-blake3-aes-128-gcm",
      "2022-blake3-aes-256-gcm", "2022-blake3-chacha20-poly1305", "none"].forEach(m => {
      let o = document.createElement("option");
      o.value = m;
      o.textContent = m;
      ssm.appendChild(o);
    });
    let tlsSec = document.getElementById("tlsSecurity");
    ["none", "tls", "reality"].forEach(x => {
      let o = document.createElement("option");
      o.value = x;
      o.textContent = x;
      tlsSec.appendChild(o);
    });
    let sn = document.getElementById("streamNetwork");
    ["tcp", "kcp", "ws", "grpc", "httpupgrade", "xhttp"].forEach(x => {
      let o = document.createElement("option");
      o.value = x;
      o.textContent = x;
      sn.appendChild(o);
    });
    let tf = document.getElementById("tlsFingerprintSelect");
    let rf = document.getElementById("realityFingerprintSelect");
    ["chrome", "firefox", "safari", "ios", "android", "edge", "360", "qq", "random", "randomized", "unsafe"].forEach(f => {
      let o1 = document.createElement("option");
      o1.value = f;
      o1.textContent = f;
      tf.appendChild(o1);
      let o2 = document.createElement("option");
      o2.value = f;
      o2.textContent = f;
      rf.appendChild(o2);
    });
  }

  
  function convertLink() {
    document.getElementById("linkErrorMsg").textContent = "";
    let link = document.getElementById("linkInput").value.trim();
    if (!link) {
      document.getElementById("linkErrorMsg").textContent = "Empty link!";
      return;
    }
    let newOut = parseLinkToOutbound(link);
    if (!newOut) {
      document.getElementById("linkErrorMsg").textContent = "Unable to parse link or unsupported scheme!";
      return;
    }
    outboundData = newOut;
    
    if (canEnableStream(outboundData.protocol) && !outboundData.streamSettings) {
      outboundData.streamSettings = {};
    }
    if (!outboundData.settings) {
      outboundData.settings = {};
    }
    fillFormFromOutbound();
    syncFormToJson();
    alert("Link imported successfully!");
    switchTab("json"); 
  }
  function parseLinkToOutbound(linkStr) {
    if (linkStr.startsWith("vmess:
    if (linkStr.startsWith("vless:
    if (linkStr.startsWith("trojan:
    if (linkStr.startsWith("ss:
    return null;
  }
  function parseVmessLink(l) {
    try {
      let b64 = l.substring(8);
      let dec = atob(b64);
      let obj = JSON.parse(dec);
      let out = getDefaultOutbound(Protocols.VMess);
      if (!isEmpty(obj.ps)) out.tag = obj.ps;
      if (!isEmpty(obj.add)) out.settings.address = obj.add;
      if (typeof obj.port === "number") out.settings.port = obj.port;
      if (!isEmpty(obj.id)) out.settings.id = obj.id;
      if (!isEmpty(obj.scy)) out.settings.security = obj.scy;
      if (obj.tls === "tls" || obj.tls === "reality") {
         out.streamSettings.security = obj.tls;
         if (obj.sni) {
           if (!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
           out.streamSettings.tlsSettings.serverName = obj.sni;
         }
         if (obj.alpn) {
           if (!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
           out.streamSettings.tlsSettings.alpn = obj.alpn.split(",");
         }
         if (obj.fp) {
           if (!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
           out.streamSettings.tlsSettings.fingerprint = obj.fp;
         }
         if (obj.allowInsecure !== undefined) {
           if (!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
           out.streamSettings.tlsSettings.allowInsecure = (obj.allowInsecure === true || obj.allowInsecure === "true");
         }
         if (obj.tls === "reality") {
           if (!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
           if(obj.publicKey) out.streamSettings.realitySettings.publicKey = obj.publicKey;
           if(obj.shortId) out.streamSettings.realitySettings.shortId = obj.shortId;
           if(obj.spiderX) out.streamSettings.realitySettings.spiderX = obj.spiderX;
         }
      }
      return out;
    } catch (e) {
      return null;
    }
  }
  function parseVlessLink(l) {
    try {
      let url = new URL(l);
      let out = getDefaultOutbound(Protocols.VLESS);
      out.settings.id = url.username;
      out.settings.address = url.hostname;
      out.settings.port = parseInt(url.port) || 443;
      out.settings.flow = url.searchParams.get("flow") || "";
      let sec = url.searchParams.get("security");
      if (sec) {
         out.streamSettings.security = sec;
         if(sec === "tls") {
           if(url.searchParams.get("sni")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.serverName = url.searchParams.get("sni");
           }
           if(url.searchParams.get("alpn")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.alpn = url.searchParams.get("alpn").split(",");
           }
           if(url.searchParams.get("fp")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.fingerprint = url.searchParams.get("fp");
           }
           if(url.searchParams.get("allowInsecure")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.allowInsecure = url.searchParams.get("allowInsecure") === "true";
           }
         } else if(sec === "reality") {
           if(url.searchParams.get("sni")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.serverName = url.searchParams.get("sni");
           }
           if(url.searchParams.get("publicKey")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.publicKey = url.searchParams.get("publicKey");
           }
           if(url.searchParams.get("shortId")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.shortId = url.searchParams.get("shortId");
           }
           if(url.searchParams.get("spiderX")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.spiderX = url.searchParams.get("spiderX");
           }
         }
      }
      if (url.hash) out.tag = decodeURIComponent(url.hash.substring(1));
      return out;
    } catch (e) {
      return null;
    }
  }
  function parseTrojanLink(l) {
    try {
      let url = new URL(l);
      let out = getDefaultOutbound(Protocols.Trojan);
      out.settings.password = url.username;
      out.settings.address = url.hostname;
      out.settings.port = parseInt(url.port) || 443;
      let sec = url.searchParams.get("security");
      if(sec) {
         out.streamSettings.security = sec;
         if(sec === "tls") {
           if(url.searchParams.get("sni")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.serverName = url.searchParams.get("sni");
           }
           if(url.searchParams.get("alpn")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.alpn = url.searchParams.get("alpn").split(",");
           }
           if(url.searchParams.get("fp")) {
             if(!out.streamSettings.tlsSettings) out.streamSettings.tlsSettings = {};
             out.streamSettings.tlsSettings.fingerprint = url.searchParams.get("fp");
           }
         } else if(sec === "reality") {
           if(url.searchParams.get("sni")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.serverName = url.searchParams.get("sni");
           }
           if(url.searchParams.get("publicKey")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.publicKey = url.searchParams.get("publicKey");
           }
           if(url.searchParams.get("shortId")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.shortId = url.searchParams.get("shortId");
           }
           if(url.searchParams.get("spiderX")) {
             if(!out.streamSettings.realitySettings) out.streamSettings.realitySettings = {};
             out.streamSettings.realitySettings.spiderX = url.searchParams.get("spiderX");
           }
         }
      }
      if (url.hash) out.tag = decodeURIComponent(url.hash.substring(1));
      return out;
    } catch (e) {
      return null;
    }
  }
  function parseSsLink(l) {
    try {
      let rest = l.substring(5);
      if (rest.indexOf('@') !== -1) {
        let parts = rest.split('@');
        let cred = parts[0];
        let server = parts[1];
        let [method, password] = cred.split(':');
        let [host, port] = server.split(':');
        let out = getDefaultOutbound(Protocols.Shadowsocks);
        out.settings.method = method;
        out.settings.password = password;
        out.settings.address = host;
        out.settings.port = parseInt(port) || 443;
        return out;
      } else {
        let decoded = atob(rest);
        let parts = decoded.split('@');
        if (parts.length < 2) return null;
        let cred = parts[0];
        let server = parts[1];
        let [method, password] = cred.split(':');
        let [host, port] = server.split(':');
        let out = getDefaultOutbound(Protocols.Shadowsocks);
        out.settings.method = method;
        out.settings.password = password;
        out.settings.address = host;
        out.settings.port = parseInt(port) || 443;
        return out;
      }
    } catch (e) {
      return null;
    }
  }

  
  function addWarpOutbound() {
    fetch('/generate_warp')
      .then(response => {
        if (!response.ok) throw new Error("Network response was not ok");
        return response.json();
      })
      .then(data => {
        
        outboundData = data;
        if (!outboundData.settings) outboundData.settings = {};
        if (canEnableStream(outboundData.protocol) && !outboundData.streamSettings) {
          outboundData.streamSettings = {};
        }
        fillFormFromOutbound();
        syncFormToJson();
        alert("Warp outbound imported. You can now review and save.");
        switchTab("json");
      })
      .catch(error => {
        alert("Error importing Warp outbound: " + error.message);
      });
  }

  
  function saveOutbound() {
    readFormIntoOutbound();
    let finalObj = outboundToJson(outboundData);
    document.getElementById("jsonEditorHidden").value = JSON.stringify(finalObj);
    document.getElementById("saveForm").submit();
  }
  
  function goBack() {
    window.history.back();
  }

  
  function initSelectOptions() {
    let ps = document.getElementById("protocolSelect");
    for (let k in Protocols) {
      let val = Protocols[k];
      let opt = document.createElement("option");
      opt.value = val;
      opt.textContent = k;
      ps.appendChild(opt);
    }
    let fds = document.getElementById("freedomDomainStrategy");
    ["AsIs", "UseIP", "UseIPv4", "UseIPv6", "UseIPv6v4", "UseIPv4v6", "ForceIP", "ForceIPv6v4", "ForceIPv6", "ForceIPv4v6", "ForceIPv4"].forEach(fd => {
      let o = document.createElement("option");
      o.value = fd;
      o.textContent = fd;
      fds.appendChild(o);
    });
    let wds = document.getElementById("wgDomainStrategy");
    ["ForceIP", "ForceIPv4", "ForceIPv4v6", "ForceIPv6", "ForceIPv6v4"].forEach(x => {
      let o = document.createElement("option");
      o.value = x;
      o.textContent = x;
      wds.appendChild(o);
    });
    let vs = document.getElementById("vmessSecurity");
    ["aes-128-gcm", "chacha20-poly1305", "auto", "none", "zero"].forEach(sec => {
      let o = document.createElement("option");
      o.value = sec;
      o.textContent = sec;
      vs.appendChild(o);
    });
    let ssm = document.getElementById("ssMethod");
    ["aes-256-gcm", "aes-128-gcm", "chacha20-poly1305", "chacha20-ietf-poly1305",
      "xchacha20-poly1305", "xchacha20-ietf-poly1305", "2022-blake3-aes-128-gcm",
      "2022-blake3-aes-256-gcm", "2022-blake3-chacha20-poly1305", "none"].forEach(m => {
      let o = document.createElement("option");
      o.value = m;
      o.textContent = m;
      ssm.appendChild(o);
    });
    let tlsSec = document.getElementById("tlsSecurity");
    ["none", "tls", "reality"].forEach(x => {
      let o = document.createElement("option");
      o.value = x;
      o.textContent = x;
      tlsSec.appendChild(o);
    });
    let sn = document.getElementById("streamNetwork");
    ["tcp", "kcp", "ws", "grpc", "httpupgrade", "xhttp"].forEach(x => {
      let o = document.createElement("option");
      o.value = x;
      o.textContent = x;
      sn.appendChild(o);
    });
    let tf = document.getElementById("tlsFingerprintSelect");
    let rf = document.getElementById("realityFingerprintSelect");
    ["chrome", "firefox", "safari", "ios", "android", "edge", "360", "qq", "random", "randomized", "unsafe"].forEach(f => {
      let o1 = document.createElement("option");
      o1.value = f;
      o1.textContent = f;
      tf.appendChild(o1);
      let o2 = document.createElement("option");
      o2.value = f;
      o2.textContent = f;
      rf.appendChild(o2);
    });
  }
  </script>
 </body>
</html>